# 在MySql 中使用show status 语句查询一些MySql 数据库的性能:


    eg：SHOW STATUS LIKE ‘value’
    其中value是要查询的参数值，一些常用的性能参数如下：
    1，connections:链接mysql服务器的次数
    2，uptime：MySql服务器的上线时间
    3，Slow_queries:慢查询次数
    4，com_select:查询操作的次数
    5，com_insert:插入操作的次数
    6，com_update:更新操作的次数
    7，com_delete:删除操作的次数

# SQL 语句优化

    基本原则：
    1）避免全表扫描
    2）建立索引
    3）尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理
    4）尽量避免大事务操作，提高系统并发能力
    5）使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。尽量避免使用游标，因为游标的效率较差。

# 关于where后的条件

    1）应尽量避免在where 字句中使用！=或<>操作符否则引擎将放弃使用索引而进行全表扫描
    2）尽量避免在where语句中使用or来连接条件，可以考虑使用union 代替
    3）慎用in和not in ,对于连续的数值，能用between 就不要用 in,exists 代替in
    4) 尽量避免在where字句中对字段进行表达式操作和函数操作

# 数据类型

    1）尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销
    2）尽可能使用varchar/nvarchar 代替char/ncahr ,因为变长字段存储空间小，对于查询来说，在一个相对较小的字段内搜索效率明显要高些。
    3)最好不要给数据库留null,尽可能使用not null 填充.数据库，备注、描述、评论之类的可以设置null,其他的尽量不要使用null
    4)任何地方都不要使用select * from t ,用具体的字段列表代替“*”，不要返回用不到的任何字段


# count():两个作用,
  
  其一统计某个列值的数量，
  其二是统计行数。统计列值时，要求列值非空，它不会统计null.如果确定括号中表达式不为null，实际就是在统计行数，即count(*).如果不需要完全进准的count 值，可以使用explain

  关联查询优化：在大数据场景下，表和表之间通过一个冗余字段来关联，要比使用join 有更好的性能。如果确实需要关联查询，需要注意：
  1，确保ON 和USING 语句的列上有索引，在创建索引的时候就要考虑到关联的顺序
  2，确保任何的GROUP BY 和ORDER BY 中的表达式只涉及到一个表的列，这样MySql 才有可能使用索引来优化

# LIMIT 分页优化：

  当需要分页操作时，通常会使用limit 加上偏移量的办法实现，同时加上合适的order by 字句。如果有对应的索引，通常效率会不错。否则MySql 需要做大量的文件排序操作。
    
  如果偏移量很大，如limit 10000,20 ,前面的10000条都将被抛弃，这样的代价非常高。
  优化方式可以使用覆盖索引扫描，而不是查询所有列，然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率提升非常大

如：
```
select film_id,description from film order by title limit 10000,20

- 1

- 1
```
改为：
```
select  film.film_id,film.description from film inner join(
select film_id,description from film order by title limit 10000,20 )AS tmp using (film_id)

- 1
- 2

- 1
- 2

select id from t limit 10000,10
改为
select id from t where id>10000 limit 10
```


# 关于临时表

    1）避免频繁创建和删除临时表，以减少系统表资源的消耗。
    2）在新建临时表的，如果一次性插入数据量很大，那么可以使用select into 代替create table,避免造成大量log,以提高速度；
          如果数据量不大，为了缓和系统表的资源，应先create table,然后insert
    3)如果使用到了临时表，在最后将所有的临时表显式删除时，先truncate table,然后drop table,这样可以避免系统表的较长时间锁定。

# 关于索引

    1）应先考虑在where 及order by 涉及的列上建立索引
    2）在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引字段的第一个字段作为条件时，才能保证系统使用该索引，否则该索引不会被使用，并且尽可能让字段顺序与索引顺序相一致。
    3）索引不是越多越好，索引固然可以提高相应的select 的效率，同时也降低了insert 和update的效率，因为insert 或update 时有可能会重建索引。所以视具体情况而定，一个表的索引数最好不要超过7个，若太多则应考虑一些不常使用的列上建立的索引是否必要。

# 建立索引的原则：

    1）定义主键的数据列一定要建立索引。（一般数据库都会给主键自动建立索引）
    2）定义有外键的数据列一定要建立索引
    3）对于经常查询的数据列最好建立索引
    4）对于需要在指定范围内快速或频繁查询的数据列
    5）经常用在where 字句中的数据列
    6）经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用
    7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
    8）对于定义为text、image和bit 的数据类型的列不要建立索引
    9）限制表上的索引数目。对于存在大量更新操作的表，所建立的索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作
    10）对于符合索引，按照字段在查询条件中的频度建立索引。在复合索引中，记录首先按照第一个字段排序，对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用，因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能的使用此索引，发挥索引的作用
    11)某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。例如下句会使用索引：

```
SELECT * FROM mytable WHERE username like'admin%'
```

下句就不会使用：

```
SELECT * FROM mytable WHEREt Name like'%admin'
```



# 一些常见的索引：

    1）BTREE 索引-mysql 中主要的索引类型
    2）RTREE索引-只有MyISAM支持，用于GIS
    3）HASH索引-MEMORY,NDB支持
    4）BITMAP 索引-MYSQL 不支持
    5）FULLTEXT 索引-MyISAM，Innodb(MySql 5.6以上支持)

# 索引的分类：

    SQL 中的索引分为两种：一种为聚焦索引，另一种非聚焦索引
    1）聚集索引：
    可以理解为顺序排列。如：如过想要查找第100条，那么直接第一条数据的地址交上100 即为第一百条的地址，一次就能查询出来。
    在mysql中，不能自己创建聚集索引，主键即为聚集索引，如果没有创建主键，那么默认非空的列为聚集索引，如果没有非空的列那么会自动生成一个隐藏列为聚集索引。
    所以一般在mysql 中，创建的主键即为聚集索引，数据是按照我们的主键顺序进行排列。所以在根据主键查询时会非常快

    2）非聚集索引
    可以理解为有序目录，是一种空间换时间的方法：
    eg:user表，有id_num 字段，这些数据在存储的时候都是无序的。
    此时如果想要查找id_num 为56的人，那么只能一条条遍历，n条就需要查询n次，时间复杂度为o(n),非常耗费性能
    如果为id_num 增加非聚集索引，添加非聚集索引后，会给id_num 进行排序（内部使用结构为B+树），并且排序后，我只需要查询此目录（即查询B+树），就能得到该条数据在数据库的位置，而不需要去遍历表中所有的数据。
    所以，在非聚集索引中，不重复的数据越多，那么索引的效率越高。

# 在mysql 中可以分为以下几种：

    1，普通索引：index(MyIASM 中默认的BTREE类型索引，也是最长用到的索引)
    2，唯一索引：unique index ：  与普通索引类似，不同的是：索引的值必须唯一，但允许有空值（和主键不同）
    3，全文索引（FULLTEXT） ：仅可用于MyISAM 表
    4，单列索引、多列索引；建立组合，因为msql在同个请求下的多个单列索引只会msql认为最优的那条单列索引
    5，组合索引（最左前缀） ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))  相当于建立了 title,time 和title 两个索引。
        

# 索引的操作

    1，创建索引
    1.1：创建普通索引
    create index 索引名 on 表名 （列名1，列名2…）
    修改表：
    alter table 表名 add index 索引名（列名1，列名2…）
    创建表时指定：
    create table 表名（[…],index 索引名（列名1，列名2…））

    1.2 创建唯一索引
              创建索引
    create unique index 索引名 on 表名（列…）
    在表上增加索引：
    alter table 表名 add unique 索引名（列…）
    创建表时指定：
    create table 表名（[…],unique 索引名（列…））

    unique:唯一索引
    CLUSTERED:聚集索引
    NONCLUSTERED:非聚集索引

    2，删除索引：
    drop index 索引名 on 表名
    alter table 表名 drop index 索引名

    3，查看索引：
    show index from 表名

    返回字段：
    table：表名
    non_unique:是否不唯一，0唯一，1不唯一
    key_name:索引的名称
    seq_in_index:索引中的列序列号，从1 开始
    column_name:列名称
    Collation：列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。
    Cardinality：索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。
    Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。
    Packed：指示关键字如何被压缩。如果没有被压缩，则为NULL。
    Null：如果列含有NULL，则含有YES。如果没有，则该列含有NO。
    Index_type：用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。
    Comment：更多评注。


# 存储引擎的选择：MyISAM vs InnoDB    

    MyISAM：支持全文索引；使用表级锁；读并发性能好。
    InnoDB：支持事务和外键；使用行级锁；写并发性能较好。

在实际应用场景中，我们一般都使用InnoDB作为默认的存储引擎，除了支持事务和行锁是比较重要的两个原因外，其实MyISAM在实际应用场景中意义也不大，看看下面几个原因：

	* 全文索引完全可以（也应该）用第三方软件来替代，比如：Sphinx；
	* 读性能高的特点完全可以用前端缓存来替代，这已经是互联网应用的标配了；
	* 表级锁在并发写操作多时会严重影响读操作（写优先）；


# 使用与优化DB的优化
	* 建立合适的索引：
      尽量让所有查询都走索引，这个效果是很明显的。
	* 表空间优化：
	  在删除或更新比较频繁的表上，如果包含varchar,text之类的字段，需要定期地执行表空间优化,optimaize table xxx，整理磁盘碎片，回收表数据和索引数据占用的空闲空间;
	* 配置参数优化：
      innodb_buffer_pool_size  innodb表数据和索引数据的内存缓冲大小，很关键，可以有效减少磁盘IO。
      innodb_flush_log_at_trx_commit 决定事务日志怎么记录，这个对性能提升也很关键，在线下批量写数据时可以考虑设置为0.或者写操作频繁但允许故障时丢失极少量数据的情况也可以考虑。
      query_cache 这个参数有些微妙，因为query cache在数据表中有任何数据修改时就会失效，对于写操作频繁的表来说，有可能还会降低性能。对于读操作为主的表来说，效果还是很明显的，但是通常场景下我们都依赖于前端缓存，所以对于这个参数的设置来说，还要看具体业务场景。
      max_connections 控制并发连接数，不能太大，否则后果很严重。
    * 拆分与扩容：
      库拆分：一般是把同一实例上的数据库分到多个实例上来分担压力（这种比较简单，做一份复制，应用端改个ip就行），或者是把一个库里面的部分表单独放到另一个实例库中（这种比较麻烦，需要应用端配合修改程序）。
      表拆分：也分两种，一种是把一些字段的拆出到新表里，比如按业务分，或者是像text之类的大字段拆分。另一种是表记录数太大，超出了单表承受能力，需要水平扩展到多张表。表拆分比较麻烦，都需要应用端配合修改程序。

# SQL的优化

	* 尽量用上索引，能用主键查询最好了
	* 尽量缩小扫描范围，经典场景就是limit分页偏移量的优化，其实在实际业务场景下很有很多类似的场景，我们完全可以按id号或者时间限制来显著缩小查询扫描范围
	* 尽量减少表连接查询，最好是单表查询（表连接可能用上临时表，对DB消耗很大；而单表查询可以快速返回，把计算操作放到前端应用去做，减少DB压力）。如果前端并发没有控制好的话，性能较差的表连接查询可能会拖死DB
	* 尽量做等值查询，不等条件查询和逆向查询不走索引
	* 用union替代or、in操作
	* 不做前置模糊查询，不走索引
	* 排序和分组操作尽量在应用端做，减少DB的CPU压力
	* 在查询列上不作函数运算：select concat('foo','bar') as str from xxx;

# 应用的优化

	* 尽量不在DB端做运算，能在应用端做的事就不依赖DB
	* text/blob之类的数据尽量不在DB中存储，可以采用其它key/value型的存储
	* 大sql拆分成小sql查，不做表连接
	* 用好连接池，减少连接开销（这里要注意连接池的空闲时间与数据库空闲时间的配置）
	* 有冷热数据的场景，尽量均摊压力
	* 考虑读写分离（这里要注意slave的延时，master写频繁的情况下，slave延时也是另人很头疼的，对数据一致性敏感的应用场景是有隐患的）
	* 最后提一下，preparedstatement，最大的作用是防止SQL注入。预编译功能也可以尝试使用，但是要开启前端sql缓存才好，这个还是看具体应用场景吧，大多数互联网应用还没到靠这个功能来提升性能的情况。

# 简单故障排查技巧慢查询排查

	* 日志查看：slow.log，这个是mysql配置文件里设置的，要开启。
	* 实时查看：select * from information_schema.processlist where time > 2;

处理方式：

    * 慢查询日志分析工具：mysqlsla,mysqldumpslow等，对症下药进行SQL优化；
	* 实时的慢查询如果影响了应用的响应，可以直接kill掉查询线程。执行kill [thread_id]即可。

```
    ·Lock情况排查确定数据库有锁住情况看两个地方，在processlist中可以看到state那一列有lock相关的状态，这里只能看到一个状态，最主要是通过下面这个命令来查看show innodb engine status，这里会显示详细的锁和事务发生的信息。至于怎么解决，要看应用端怎么来控制了。
    ·Slave延时排查在slave实例上执行show slave status查看slave的状态，主要关注以下三个：
    ·Slave_IO_Running: Yes // 负责读取binlog的线程是否正常运行Slave_SQL_Running: Yes // 负责在slave上执行sql的线程是否正常运行Seconds_Behind_Master: 0 // slave比master延时多长时间，单位：秒
    ·如果出现IO和SQL线程状态为No的情况，那说明slave同步已经停止了，可以通过Last_Error这个看到最近的错误。如果要恢复slave，一般两种操作：一是重做slave，保证数据更准确；一种是跳过出错的sql，stop slave;set global sql_slave_skip_counter=1;start slave;，这是跳过一条sql，也可跳过多条，这种方式可能导致slave数据不一致。
    ·监控内置命令status
    ·show global statusshow variables
    ·外部监控第三方的监控工具，可以提供图形化的界面。cacti,ganglia等开源软件都提供了监控mysql的插件。
```

# mysql高可用两种方式：

    方式一：使用MySQL Cluster：读扩展性好，写性能会有一定下降。不是很成熟，线上慎用。
    方式二：Master + Slave配合虚拟IP + LVS + keepalived实现简单的高可用，这种方案的隐患就是：虚拟ip切换间隙会有短暂不可用；slave提升到master会有失败的情况；

